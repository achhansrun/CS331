Intro to PL's:

    PL Specification: Description to write a compiler.
    Dynamic vs. Static: Runtime vs. before runtime.
    Syntax vs. Semantics: Structure vs. meaning of code.
    Parsing: Checking structure and syntax.
    Formal Language: Set of strings.
    Generator vs. Recognizer: Produces strings vs. checks if a string is in a language.
    Grammar: Rules for altering strings.
    Alphabet: Characters in a language.
    Derivation: Resulting string from a grammar.

Chomsky Hierarchy:

    Categories: Regular, Context-Free, Context-Sensitive, Computably Enumerable.
    Regular Language: Generated by regular grammar.
    Context-Free Language: Generated by CFG.
    Computably Enumerable Language: Described by unrestricted grammar.
    DFA and PDA: Recognizers for regular and context-free languages.

Regular Languages:

    Arithmetic Expressions: Involving numbers, identifiers, operators.
    Regular Expressions (Regex): Patterns for string matching.
    Regex Operators: Kleene Star, Concatenation, Alternation, etc.
    DFA: Recognizes regular languages.
    Regex Special Characters: Kleene Star, Dot, Brackets, etc.

Context-Free Languages:

    CFG: Grammar with single non-terminal left-hand sides.
    Ambiguity: Multiple parse trees for a string.
    Left/Rightmost Derivation: Expanding left/rightmost non-terminal.
    Parse Tree vs. Derivation: Visual vs. list of strings.

PL Syntax Specification:

    BNF/EBNF: Notations for CFG.
    Lexical Analysis: Break code into lexemes.
    Dangling Else: Ambiguity in if-else chains.
    Type System: Classifies expressions/values.
    Compiler vs. Interpreter: Transforms vs. executes code.
    Intermediate Representation: Before target language.
    Dynamic PL's: Support dynamic typing, imperative style.
    Shebang Line: Defines interpreter for a script.

Dynamic PL's:

    Batch Files, Scripts: Sequence of commands.
    AWK, Perl: Early script-based languages.
    Dynamic PL Features: Dynamic typing, imperative style.
    Type Safety: Prevents undesirable states.
    Closure, Duck Typing: Functional concepts.

Haskell Fundamentals:

    Functional Programming: Focuses on function evaluation.
    Declarative Programming: Defines what's true.
    Pattern Matching: Different functions for different patterns.
    Lazy Evaluation: Delayed computation until needed.

Haskell Functions/Lists:

    Higher-Order Functions: Functions acting on functions.
    Currying: Single-arg functions returning functions.
    Lists: Homogeneous collections, recursive operations.
    List Comprehension: Constructing lists from other lists.

Haskell Flow of Control:

    Guards: Piecewise function definitions.
    Fold/Reduce: Operation on all items in a collection.

Haskell I/O:

    Typeclasses: Common interfaces for types.
    Do-Expression: Sequential I/O actions.
    Handles: Identifies and accesses open files.
    Flush: Writes buffered I/O.
    Return in Haskell: Creates a do-nothing I/O action.

General Parsing Concepts:

    Parsing Expression Grammar: Alternative to CFG.
    LL(k)/LR(k) Grammars: Decision lookahead for parsing.
    Recursive Descent Parsing: Top-down parsing method.
    Shift-Reduce Parsing: Bottom-up parsing method.
    Parsing Table: Actions and GOTO tables for SR parsing.